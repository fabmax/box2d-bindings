[NoDelete]
interface B2_World {
    // World creation and management
    static void defaultWorldDef([Ref] b2WorldDef result);
    static unsigned long long createWorld([Const] b2WorldDef def);
    static void destroyWorld(unsigned long long worldId);
    static boolean isValid(unsigned long long worldId);

    // Simulation
    static void step(unsigned long long world, float timeStep, long subStepCount);
    // static void draw(unsigned long long worldId, b2DebugDraw draw);

    // Event handling
    [Value] static b2BodyEvents getBodyEvents(unsigned long long worldId);
    [Value] static b2SensorEvents getSensorEvents(unsigned long long worldId);
    [Value] static b2ContactEvents getContactEvents(unsigned long long worldId);

    // Query and collision detection
    // [Value] static b2TreeStats overlapAABB(unsigned long long worldId, [Value] b2AABB aabb, [Value] b2QueryFilter filter, b2OverlapResultFcn fcn, VoidPtr context);
    // [Value] static b2TreeStats overlapShape(unsigned long long worldId, [Const] b2ShapeProxy proxy, [Value] b2QueryFilter filter, b2OverlapResultFcn fcn, VoidPtr context);
    // [Value] static b2TreeStats castRay(unsigned long long worldId, [Value] b2Vec2 origin, [Value] b2Vec2 translation, [Value] b2QueryFilter filter, b2CastResultFcn fcn, VoidPtr context);
    // [Value] static b2RayResult castRayClosest(unsigned long long worldId, [Value] b2Vec2 origin, [Value] b2Vec2 translation, [Value] b2QueryFilter filter);
    // [Value] static b2TreeStats castShape(unsigned long long worldId, [Const] b2ShapeProxy proxy, [Value] b2Vec2 translation, [Value] b2QueryFilter filter, b2CastResultFcn fcn, VoidPtr context);
    // static float castMover(unsigned long long worldId, [Const] b2Capsule mover, [Value] b2Vec2 translation, [Value] b2QueryFilter filter);
    // static void collideMover(unsigned long long worldId, [Const] b2Capsule mover, [Value] b2QueryFilter filter, b2PlaneResultFcn fcn, VoidPtr context);

    // World settings
    static void enableSleeping(unsigned long long worldId, boolean flag);
    static boolean isSleepingEnabled(unsigned long long worldId);
    static void enableContinuous(unsigned long long worldId, boolean flag);
    static boolean isContinuousEnabled(unsigned long long worldId);
    static void setRestitutionThreshold(unsigned long long worldId, float value);
    static float getRestitutionThreshold(unsigned long long worldId);
    static void setHitEventThreshold(unsigned long long worldId, float value);
    static float getHitEventThreshold(unsigned long long worldId);
    static void setGravity(unsigned long long worldId, [Value] b2Vec2 gravity);
    [Value] static b2Vec2 getGravity(unsigned long long worldId);

    // Callbacks
    // static void setCustomFilterCallback(unsigned long long worldId, b2CustomFilterFcn fcn, VoidPtr context);
    // static void setPreSolveCallback(unsigned long long worldId, b2PreSolveFcn fcn, VoidPtr context);
    // static void setFrictionCallback(unsigned long long worldId, b2FrictionCallback callback);
    // static void setRestitutionCallback(unsigned long long worldId, b2RestitutionCallback callback);

    // Advanced features
    static void explode(unsigned long long worldId, [Const] b2ExplosionDef explosionDef);
    static void setContactTuning(unsigned long long worldId, float hertz, float dampingRatio, float pushSpeed);
    static void setMaximumLinearSpeed(unsigned long long worldId, float maximumLinearSpeed);
    static float getMaximumLinearSpeed(unsigned long long worldId);
    static void enableWarmStarting(unsigned long long worldId, boolean flag);
    static boolean isWarmStartingEnabled(unsigned long long worldId);

    // Statistics and debugging
    static long getAwakeBodyCount(unsigned long long worldId);
    [Value] static b2Profile getProfile(unsigned long long worldId);
    [Value] static b2Counters getCounters(unsigned long long worldId);
    static void dumpMemoryStats(unsigned long long worldId);

    // User data
    static void setUserData(unsigned long long worldId, VoidPtr userData);
    static VoidPtr getUserData(unsigned long long worldId);

    // Internal testing functions
    static void rebuildStaticTree(unsigned long long worldId);
    static void enableSpeculative(unsigned long long worldId, boolean flag);
};

[StackAllocatable]
interface b2BodyEvents {
    attribute long moveCount;
    attribute b2BodyMoveEvent moveEvents;
};

[StackAllocatable]
interface b2BodyMoveEvent {
    [Value] attribute b2BodyId bodyId;
    attribute boolean fellAsleep;
    [Value] attribute b2Transform transform;
    attribute VoidPtr userData;
};

[StackAllocatable]
interface b2SensorEvents {
    attribute long beginCount;
    attribute b2SensorBeginTouchEvent beginEvents;
    attribute long endCount;
    attribute b2SensorEndTouchEvent endEvents;
};

[StackAllocatable]
interface b2SensorBeginTouchEvent {
    [Value] attribute b2ShapeId sensorShapeId;
    [Value] attribute b2ShapeId visitorShapeId;
};

[StackAllocatable]
interface b2SensorEndTouchEvent {
    [Value] attribute b2ShapeId sensorShapeId;
    [Value] attribute b2ShapeId visitorShapeId;
};

[StackAllocatable]
interface b2ContactEvents {
    attribute long beginCount;
    attribute b2ContactBeginTouchEvent beginEvents;
    attribute long endCount;
    attribute b2ContactEndTouchEvent endEvents;
    attribute long hitCount;
    attribute b2ContactHitEvent hitEvents;
};

[StackAllocatable]
interface b2ContactBeginTouchEvent {
    [Value] attribute b2Manifold manifold;
    [Value] attribute b2ShapeId shapeIdA;
    [Value] attribute b2ShapeId shapeIdB;
};

[StackAllocatable]
interface b2ContactEndTouchEvent {
    [Value] attribute b2ShapeId shapeIdA;
    [Value] attribute b2ShapeId shapeIdB;
};

[StackAllocatable]
interface b2ContactHitEvent {
    attribute float approachSpeed;
    [Value] attribute b2Vec2 normal;
    [Value] attribute b2Vec2 point;
    [Value] attribute b2ShapeId shapeIdA;
    [Value] attribute b2ShapeId shapeIdB;
};

[StackAllocatable]
interface b2Manifold {
    [Value] attribute b2Vec2 normal;
    attribute long pointCount;
    [Value] attribute b2ManifoldPoint[] points;
    attribute float rollingImpulse;
};

[StackAllocatable]
interface b2ManifoldPoint {
    [Value] attribute b2Vec2 anchorA;
    [Value] attribute b2Vec2 anchorB;
    attribute unsigned short id;
    attribute float normalImpulse;
    attribute float normalVelocity;
    attribute boolean persisted;
    [Value] attribute b2Vec2 point;
    attribute float separation;
    attribute float tangentImpulse;
    attribute float totalNormalImpulse;
};

[StackAllocatable]
interface b2ExplosionDef {
    void b2ExplosionDef();
    attribute float falloff;
    attribute float impulsePerLength;
    attribute unsigned long long maskBits;
    [Value] attribute b2Vec2 position;
    attribute float radius;
};

[StackAllocatable]
interface b2WorldDef {
    void b2WorldDef();
    [Value] attribute b2Vec2 gravity;
    attribute float restitutionThreshold;
    attribute float hitEventThreshold;
    attribute float contactHertz;
    attribute float contactDampingRatio;
    attribute float maxContactPushSpeed;
    attribute float maximumLinearSpeed;
    // b2FrictionCallback * 	frictionCallback
    // b2RestitutionCallback * 	restitutionCallback
    attribute boolean enableSleep;
    attribute boolean enableContinuous;
    // attribute long workerCount;
    // b2EnqueueTaskCallback * 	enqueueTask
    // b2FinishTaskCallback * 	finishTask
    // attribute VoidPtr userTaskContext;
    attribute VoidPtr userData;
};

interface b2Counters {
    void b2Counters();
    attribute long bodyCount;
    attribute long shapeCount;
    attribute long contactCount;
    attribute long jointCount;
    attribute long islandCount;
    attribute long stackUsed;
    attribute long staticTreeHeight;
    attribute long treeHeight;
    attribute long byteCount;
    attribute long taskCount;
    attribute long[] colorCounts;
};

interface b2Profile {
    void b2Profile();
    attribute float step;
    attribute float pairs;
    attribute float collide;
    attribute float solve;
    attribute float mergeIslands;
    attribute float prepareStages;
    attribute float solveConstraints;
    attribute float prepareConstraints;
    attribute float integrateVelocities;
    attribute float warmStart;
    attribute float solveImpulses;
    attribute float integratePositions;
    attribute float relaxImpulses;
    attribute float applyRestitution;
    attribute float storeImpulses;
    attribute float splitIslands;
    attribute float transforms;
    attribute float hitEvents;
    attribute float refit;
    attribute float bullets;
    attribute float sleepIslands;
    attribute float sensors;
};